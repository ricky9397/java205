-- 2021.06.11

-- JOIN

-- CROSS JOIN
-- 스키마의 합 : 집합의 곱 연산과 같다

-- EQUI JOIN
SELECT *
FROM EMP, DEPT
WHERE EMP.DEPTNO=DEPT.DEPTNO;

-- 이름이 SCOTT인 사람의 WHERE E.ENAME='SCOTT'
-- 부서명을 출력해봅시다.
-- 출력해야하는 컬럼을 가지는 테이블을 확인해보자.
-- 이름 : EMP, 부서명 : DEPT
SELECT E.ENAME, D.DNAME, E.DEPTNO
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO AND ENAME='SCOTT'
ORDER BY D.DNAME, E.ENAME;

-- MYSQL에선 INNER JOIN ON 으로 사용하자.
SELECT * 
FROM EMP E INNER JOIN DEPT D
ON E.DEPTNO=D.DEPTNO
WHERE E.ENAME='SCOTT';

-- SELF JOIN " 자기 자신을 조인 ( 참조 )
-- EMP -> MGR 컬럼이 EMP.EMPNO 참조
SELECT E.ENAME, E.MGR, M.ENAME
FROM EMP E, EMP M
WHERE E.MGR=M.EMPNO(+);


-- NON EQUI JOIN
-- 동등 비교가 아닌 크다 작다와 같은 비교로 조인의 조건을 작성
SELECT * FROM SALGRADE;

SELECT E.ENAME, E.SAL, S.GRADE, S.LOSAL, S.HISAL
FROM EMP E, SALGRADE S
--WHERE E.SAL>=S.LOSAL AND E.SAL<=S.HISAL
WHERE SAL BETWEEN S.LOSAL AND S.HISAL
ORDER BY E.ENAME;

-- ANSI CROSS JOIN
SELECT *
FROM EMP CROSS JOIN DEPT;

SELECT * FROM ORDERS;
SELECT * FROM CUSTOMER;
SELECT * FROM BOOK;

-- 3개의 테이블 JOIN
SELECT O.ORDERID, C.NAME, B.BOOKNAME
FROM ORDERS O, CUSTOMER C, BOOK B
WHERE O.CUSTID=C.CUSTID AND O.BOOKID=B.BOOKID
ORDER BY O.ORDERID;

-- ANSI -> INNER JOIN
-- 오라클 EQUI JOIN

SELECT *
FROM EMP, DEPT
WHERE EMP.DEPTNO=DEPT.DEPTNO;

SELECT *
FROM EMP E INNER JOIN DEPT D
ON E.DEPTNO=D.DEPTNO;

-- 비교하는 컬럼의 이름이 같을 때
-- ON 절을 생략하고 -> USING 을 이용하면 조건식을 간략하게 처리가능
SELECT * 
FROM EMP E INNER JOIN DEPT D
--ON E.DEPTNO=D.DEPTNO
USING (DEPTNO)
WHERE E.ENAME='SCOTT';

-- NATURAL JOIN
SELECT *
FROM EMP NATURAL JOIN DEPT;

-- OUTER JOIN
SELECT E.ENAME, E.MGR, M.ENAME
FROM EMP E, EMP M
WHERE E.MGR=M.EMPNO(+); --> 표현하고자 하는 컬럼이 테이블의 반대쪽, NULL 값을 가지는 위치에 (+)

-- [LEFT | RIGHT | FULL] OUTER JOIN
SELECT E.ENAME, E.MGR, M.ENAME AS "관리자"
--FROM EMP E LEFT OUTER JOIN EMP M
FROM EMP M RIGHT OUTER JOIN EMP E
ON E.MGR=M.EMPNO;

-- 회원별 구매 내역출력
SELECT C.NAME, COUNT(O.ORDERID) AS "구매횟수", AVG(SALEPRICE)
FROM ORDERS O, CUSTOMER C
WHERE O.CUSTID(+)=C.CUSTID
GROUP BY C.NAME
ORDER BY C.NAME;

